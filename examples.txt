use cases
----------
1. 10 + 2

3. 10 - 3

5. x = 1
   y = 2
   z = x + y
   print(z)


6. x = 50 + -10
   print(x)

7. x = 50 + -10
   print(x + 10)

8. 50 + -10


thoughts
------------
how do i design my system such that it *guarantees* that a valid expreesion
gets compiled correctly to x86?

easy to understand
ready for change
safe from bugs



example 1
x = 50 + -10
print(x)
|
V
temp_0 = -10
x = 50 + temp_0
print(x)
|
V
pushq %rbp
movq %rsp, %rbp
subq $16, %rbp
movq $10, temp_0
negq temp_0
movq %50, x
addq temp_0, x
movq x, %rdi
callq print_int
|
V
pushq %rbp
movq %rsp, %rbp
subq $16, %rbp
movq $10, -8(%rsp)
negq -8(%rsp)
movq $50 -16(%rsp)
addq -8(%rsp) -16(%rsp)
movq -16(%rsp) %rdi
callq print_int
addq %16, %rsp
popq %rbp
retq
|
V
pushq %rbp
movq %rsp, %rbp
subq $16, %rbp
movq %10, -8(%rsp)
negq -8(%rsp)
movq $50 -16(%rsp)
addq -8(%rsp) %rax
addq %rax, -16(%rsp)
movq -16(%rsp) %rdi
callq print_int
addq %16, %rsp
popq %rbp
retq
-----------------------

example2
------------

x = 50 + -10
print(x + 10)

    |
    |
remove-complex-operands
    |
    V
temp_0 = -10
x = 50 + temp_0
temp_1 = x + 10
print(temp_1)

    |
  instruction selection
    |
    V
pushq %rbp
movq %rsp, %rbp
subq $32, %rbp
movq $10, temp_0
negq temp_0
movq $50, x
addq temp_0, x
movq 10, temp_1
addq x, temp_1
callq print_int
addq %16, %rsp
popq %rbp
retq

|
assign homes
|
V
pushq %rbp
movq %rsp, %rbp
subq $32, %rbp
movq $10, -8(%rsp)
negq -8(%rsp)
movq $50, -16(%rsp)
addq -8(%rsp) -16(%rsp)
movq 10, -24(%rsp)
addq -16(%rsp) -24(%rsp)
callq print_int
addq %32, %rsp
popq %rbp
retq

|
|
patch-instructions
|
V
pushq %rbp
movq %rsp, %rbp
subq $32, %rbp
movq $10, -8(%rsp)
negq -8(%rsp)
movq $50, -16(%rsp)
addq -8(%rsp), %rax
movq %rax, -16(%rsp)
movq 10, -24(%rsp)
addq -16(%rsp), %rax
movq %rax, -24(%rsp)
callq print_int
addq %32, %rsp
popq %rbp
retq
----------
example 3
------------
x = 10 + -3
y = 2
z = x + y
print(z)
|
|
remove-complex-operands
|
V
temp_0 = -3
x = 10 + temp_0
y = 2
z = x + y
print(z)
|
|
select-instructions
|
V
pushq %rbp
movq %rsp, %rbp
subq $32, %rbp
movq $3, temp_0
negq temp_0
movq 10, x
addq temp_0, x
movq 2 y
movq y z
addq x z
movq z, %rdi
callq print_int
addq %32, %rsp
popq %rbp
retq

|
assign-homes
|
V

pushq %rbp
movq %rsp, %rbp
subq $32, %rbp
movq $3, -8(%rbp)
negq -8(%rbp)
movq 10, -16(%rbp)
addq -8(%rbp) -16(%rbp)
movq 2 -32(%rbp)
movq -32(%rbp) -64(%rbp)
addq -16(%rbp) -64(%rbp)
movq -64(%rbp) %rdi
callq print_int
addq %32, %rsp
popq %rbp
retq

-----------
conditional examples

if 2==2:
  x = 40 + -30
  print(x)
else:
  y = 3 + -2
  print(y)

  |
  V
if 2!=2:
   goto block_1

   temp_1 = -30
   x = 40 + temp_1
   print(x)

block_1:
   temp_2 = -2
   y = 3 + temp_2
   print(y)

|
V
movq $2 %rsi
movq $2 %rdi
cmpq %rdi %rsi
sete %al
jmp block_1
movq 30 temp_1
negq temp_1
movq 40 x
addq temp_1 x
movq x, %rdi
callq print_int

block_1:

movq 2 temp_2
negq temp_2
movq 3 y
addq temp_2 y
movq y %rdi
callq print_int


----------
example while loop

x = 8
while x > 1:
   print(x)
   x = x - 1
